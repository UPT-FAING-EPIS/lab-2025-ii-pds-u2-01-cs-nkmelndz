{
  "Bank/Cobertura/SummaryGithub.html": {
    "href": "Bank/Cobertura/SummaryGithub.html",
    "title": "Summary | Bank App",
    "summary": "Summary Summary Generated on: 15/10/2025 - 21:18:05 Coverage date: 15/10/2025 - 21:15:33 - 15/10/2025 - 21:17:45 Parser: MultiReport (2x Cobertura) Assemblies: 1 Classes: 8 Files: 8 Line coverage: 79.6% (47 of 59) Covered lines: 47 Uncovered lines: 12 Coverable lines: 59 Total lines: 126 Branch coverage: 33.3% (2 of 6) Covered branches: 2 Total branches: 6 Method coverage: Feature is only available for sponsors Coverage Bank.Domain - 79.6% Name Line Branch Bank.Domain 79.6% 33.3% Bank.Domain.CreditCardFactory 50% 33.3% Bank.Domain.CreditCardFactoryMethod 100% Bank.Domain.MoneyBack 100% Bank.Domain.MoneyBackFactoryMethod 0% Bank.Domain.Platinum 100% Bank.Domain.PlatinumFactoryMethod 100% Bank.Domain.Titanium 100% Bank.Domain.TitaniumFactoryMethod 100%"
  },
  "Bank/disenio.html": {
    "href": "Bank/disenio.html",
    "title": "| Bank App",
    "summary": "classDiagram class CreditCardFactoryMethod CreditCardFactoryMethod : +CreateProduct() ICreditCard class CreditCardFactory CreditCardFactory : +GetCreditCard() ICreditCard class ICreditCard ICreditCard : +GetCardType() String ICreditCard : +GetCreditLimit() Int ICreditCard : +GetAnnualCharge() Int class MoneyBack MoneyBack : +GetCardType() String MoneyBack : +GetCreditLimit() Int MoneyBack : +GetAnnualCharge() Int class MoneyBackFactoryMethod MoneyBackFactoryMethod : +CreateProduct() ICreditCard class Platinum Platinum : +GetCardType() String Platinum : +GetCreditLimit() Int Platinum : +GetAnnualCharge() Int class PlatinumFactoryMethod PlatinumFactoryMethod : +CreateProduct() ICreditCard class Titanium Titanium : +GetCardType() String Titanium : +GetCreditLimit() Int Titanium : +GetAnnualCharge() Int class TitaniumFactoryMethod TitaniumFactoryMethod : +CreateProduct() ICreditCard ICreditCard <|.. MoneyBack CreditCardFactoryMethod <|-- MoneyBackFactoryMethod ICreditCard <|.. Platinum CreditCardFactoryMethod <|-- PlatinumFactoryMethod ICreditCard <|.. Titanium CreditCardFactoryMethod <|-- TitaniumFactoryMethod"
  },
  "README.html": {
    "href": "README.html",
    "title": "SESION DE LABORATORIO N° 01: PATRONES DE DISEÑO CREACIONALES | Bank App",
    "summary": "SESION DE LABORATORIO N° 01: PATRONES DE DISEÑO CREACIONALES Nombre: OBJETIVOS Comprender el funcionamiento de algunos patrones de diseño de software del tipo creacional. REQUERIMIENTOS Conocimientos: Conocimientos básicos de Bash (powershell). Conocimientos básicos de Contenedores (Docker). Hardware: Virtualization activada en el BIOS.. CPU SLAT-capable feature. Al menos 4GB de RAM. Software: Windows 10 64bit: Pro, Enterprise o Education (1607 Anniversary Update, Build 14393 o Superior) Docker Desktop Powershell versión 7.x Net 8 o superior Visual Studio Code Markdown Preview Mermaid Support Mermaid Markdown Syntax Highlighting CONSIDERACIONES INICIALES Clonar el repositorio mediante git para tener los recursos necesarios DESARROLLO PARTE I: Factory Design Pattern Iniciar la aplicación Powershell o Windows Terminal en modo administrador Ejecutar el siguiente comando para crear una nueva solución dotnet new sln -o Bank dotnet tool install -g dll2mmd dotnet tool install -g docfx dotnet tool install -g dotnet-reportgenerator-globaltool Acceder a la solución creada y ejecutar el siguiente comando para crear una nueva libreria de clases y adicionarla a la solución actual. cd Bank dotnet new classlib -o Bank.Domain dotnet sln add ./Bank.Domain/Bank.Domain.csproj Ejecutar el siguiente comando para crear un nuevo proyecto de pruebas y adicionarla a la solución actual dotnet new nunit -o Bank.Domain.Tests dotnet sln add ./Bank.Domain.Tests/Bank.Domain.Tests.csproj dotnet add ./Bank.Domain.Tests/Bank.Domain.Tests.csproj reference ./Bank.Domain/Bank.Domain.csproj Iniciar Visual Studio Code (VS Code) abriendo el folder de la solución como proyecto. En el proyecto Bank.Domain, si existe un archivo Class1.cs proceder a eliminarlo. Asimismo en el proyecto Bank.Domain.Tests si existiese un archivo UnitTest1.cs, también proceder a eliminarlo. En VS Code, en el proyecto Bank.Domain proceder a crear el archivo ICreditCard.cs e introducir el siguiente código: namespace Bank.Domain { public interface ICreditCard { string GetCardType(); int GetCreditLimit(); int GetAnnualCharge(); } } En el proyecto Bank.Domain proceder a crear las implementaciones de a interfaz creada en el paso previo para eso añadimos los archivos: MoneyBack.cs namespace Bank.Domain { public class MoneyBack : ICreditCard { public string GetCardType() { return \"MoneyBack\"; } public int GetCreditLimit() { return 15000; } public int GetAnnualCharge() { return 500; } } } Platinum.cs namespace Bank.Domain { public class Platinum : ICreditCard { public string GetCardType() { return \"Platinum Plus\"; } public int GetCreditLimit() { return 35000; } public int GetAnnualCharge() { return 2000; } } } Titanium.cs namespace Bank.Domain { public class Titanium : ICreditCard { public string GetCardType() { return \"Titanium Edge\"; } public int GetCreditLimit() { return 25000; } public int GetAnnualCharge() { return 1500; } } } Luego en el proyecto Bank.Domain.Tests añadir un nuevo archivo CreditCardTests.cs e introducir el siguiente código: using Bank.Domain; using NUnit.Framework; namespace Bank.Domain.Tests { public class CreditCardTests { [Test] public void GivenCreditTypeSelected_WhenRequestCreditCard_ThenNewValidCreditCard() { string cardType = \"MoneyBack\"; ICreditCard? cardDetails = null; if (cardType == \"MoneyBack\") { cardDetails = new MoneyBack(); } else if (cardType == \"Titanium\") { cardDetails = new Titanium(); } else if (cardType == \"Platinum\") { cardDetails = new Platinum(); } Assert.IsNotNull(cardDetails); Assert.IsNotEmpty(cardDetails.GetCardType()); Assert.GreaterOrEqual(cardDetails.GetCreditLimit(), 0); Assert.GreaterOrEqual(cardDetails.GetAnnualCharge(), 0); } } } Ahora necesitamos comprobar las pruebas contruidas para eso abrir un terminal en VS Code (CTRL + Ñ) o vuelva al terminal anteriormente abierto, y ejecutar los comandos: dotnet test --collect:\"XPlat Code Coverage\" Si las pruebas se ejecutaron correctamente debera aparcer un resultado similar al siguiente: Passed! - Failed: 0, Passed: 1, Skipped: 0, Total: 1, Duration: 5 ms Funciona pero ¿es correcta la implementación del código? ¿Qué problemas tiene esta implementación? Primero tenemos un problema de Alto Acoplamiento entre la clase de prueba y las clases productos (MoneyBack, Titanium y Platinum). Asi que cuando hay un cambio en una d elas clases todas las demàs deberan ser cambiadas. Segundo, si se adiciona un nuevo tipo de tarjeta de crédito, necesitamos hacer cambios en la lògica de creación que se encuentra en el metod de prueba, adicionando una nueva condición IF-ELSE lo cual no solo complica el desarrollo, sino también el proceso pruebas. Para solucionar los problemas anteriores mencionados utilizaremos el patrón de diseño FABRICA, para lo cual ahora en el proyecto Bank.Domain proceder a agregar el archivo CreditCarFactory.cs con el siguiente código: namespace Bank.Domain { public class CreditCardFactory { public static ICreditCard GetCreditCard(string cardType) { ICreditCard? cardDetails = null; if (cardType == \"MoneyBack\") { cardDetails = new MoneyBack(); } else if (cardType == \"Titanium\") { cardDetails = new Titanium(); } else if (cardType == \"Platinum\") { cardDetails = new Platinum(); } return cardDetails; } } } Adicionalmente modificar la clase de pruebas CreditCardTests, con el siguiente código: using Bank.Domain; using NUnit.Framework; namespace Bank.Domain.Tests { public class CreditCardTests { [Test] public void GivenCreditTypeSelected_WhenRequestCreditCard_ThenNewValidCreditCard() { string cardType = \"MoneyBack\"; ICreditCard? cardDetails = CreditCardFactory.GetCreditCard(cardType); Assert.IsNotNull(cardDetails); Assert.IsNotEmpty(cardDetails.GetCardType()); Assert.GreaterOrEqual(cardDetails.GetCreditLimit(), 0); Assert.GreaterOrEqual(cardDetails.GetAnnualCharge(), 0); } } } Al ejecutar nuevamente el paso 9 deberia seguir funcionando correctamente. Con esto se aplicado el patrón de diseño FABRICA de la siguiente manera: Pero con este patrón se ha solucionado parcialmente los problemas indicados en el punto 11, en especifico solo se ha reducido en cierto porcentaje el Alto Acoplamiento. En el terminal, ejecutar el siguiente comando para generar el diagrama de clases respectivo dll2mmd -f Bank.Domain/bin/Debug/net8.0/Bank.Domain.dll -o disenio.md PARTE II: Factory Method Design Pattern Utilizando el proyecto de la primera parte proceder a crear el archivo CreditCardAbstractMethod.cs en el proyecto Bank.Domain namespace Bank.Domain { public abstract class CreditCardFactoryMethod { protected abstract ICreditCard MakeProduct(); // Also note that The Creator's primary responsibility is not creating products. // Usually, it contains some core business logic that relies on Product objects, returned by the factory method. public ICreditCard CreateProduct() { //Call the MakeProduct which will create and return the appropriate object ICreditCard creditCard = this.MakeProduct(); //Return the Object to the Client return creditCard; } } } En el Visual Studio Code, proceder a crear las implementaciones de la clase abstracta anterior para cada producto, crear los siguientes archivos en el proyecto Bank.Domain: MoneyBackFactoryMethod.cs namespace Bank.Domain { public class MoneyBackFactoryMethod : CreditCardFactoryMethod { protected override ICreditCard MakeProduct() { ICreditCard product = new MoneyBack(); return product; } } } PlatinumFactoryMethod.cs namespace Bank.Domain { public class PlatinumFactoryMethod: CreditCardFactoryMethod { protected override ICreditCard MakeProduct() { ICreditCard product = new Platinum(); return product; } } } TitaniumFactoryMethod.cs namespace Bank.Domain { public class TitaniumFactoryMethod : CreditCardFactoryMethod { protected override ICreditCard MakeProduct() { ICreditCard product = new Titanium(); return product; } } } Para probar esta implementacón, modificar la clase de pruebas CreditCardTests y adicionar los siguientes métodos: [Test] public void GivenCreditTypePlatinumChoosen_WhenRequestCreditCard_ThenNewValidCreditCard() { ICreditCard creditCard = new PlatinumFactoryMethod().CreateProduct(); Assert.IsNotNull(creditCard); Assert.IsNotEmpty(creditCard.GetCardType()); Assert.GreaterOrEqual(creditCard.GetCreditLimit(), 0); Assert.GreaterOrEqual(creditCard.GetAnnualCharge(), 0); } [Test] public void GivenCreditTypeTitaniumChoosen_WhenRequestCreditCard_ThenNewValidCreditCard() { ICreditCard creditCard = new TitaniumFactoryMethod().CreateProduct(); Assert.IsNotNull(creditCard); Assert.IsNotEmpty(creditCard.GetCardType()); Assert.AreEqual(creditCard.GetCardType(),\"Titanium Edge\"); Assert.GreaterOrEqual(creditCard.GetCreditLimit(), 0); Assert.GreaterOrEqual(creditCard.GetAnnualCharge(), 0); } Ejecutar nuevamente el paso 9 (Parte I) para lo cual se obtendra una respuesta similar a la siguiente: Passed! - Failed: 0, Passed: 3, Skipped: 0, Total: 3, Duration: 9 ms Finalmente podemos confirmar con este patròn un desacoplamiento de la clase que lo ejecuta, asimismo la reglas de creación ya no dependen de las clausula IF-ELSE, por lo que para crear un nuevo tipo de tarjeta solo será necesario crear una nueva clase basada en la clase abstracta de CreditCardFactoryMethod: En el terminal, ejecutar el siguiente comando para generar el reporte de cobertura en formato markdown. ReportGenerator \"-reports:./*/*/*/coverage.cobertura.xml\" \"-targetdir:Cobertura\" -reporttypes:MarkdownSummaryGithub En el terminal, ejecutar el siguiente comando para generar el diagrama de clases respectivo dll2mmd -f Bank.Domain/bin/Debug/net8.0/Bank.Domain.dll -o disenio.md En el terminal, ejecutar el siguiente comando para generar el diagrama de clases respectivo docfx init -y En el Visual Studio Code, eliminar los archivos de la carpeta o directorio docs, seguidamente modificar los archivos con el siguiente contenido: docfx.json { \"$schema\": \"https://raw.githubusercontent.com/dotnet/docfx/main/schemas/docfx.schema.json\", \"metadata\": [ { \"src\": [ { \"src\": \".\", \"files\": [ \"**/*.csproj\" ] } ], \"dest\": \"docs\" } ], \"build\": { \"content\": [ { \"files\": [ \"**/*.{md,yml}\" ], \"exclude\": [ \"_site/**\" ] } ], \"resource\": [ { \"files\": [ \"images/**\" ] } ], \"output\": \"_site\", \"template\": [ \"default\", \"modern\" ], \"globalMetadata\": { \"_appName\": \"Bank.App\", \"_appTitle\": \"Bank App\", \"_enableSearch\": true, \"pdf\": true } } } toc.yml - name: Docs href: docs/ index.md --- _layout: landing --- # This is the **HOMEPAGE**. ## [Diagrama de Clases](disenio.md) ## [Pruebas](Cobertura/SummaryGithub.md) En el terminal, ejecutar el siguiente comando para generar la documentacion docfx metadata docfx.json docfx build En un explorador de windows, ingresar a la ruta del proyecto dentro de la carpeta _site, abrir el archivo index.html, y debera visalizar algo como siguiente. Actividades Encargadas Completar la documentación de todas las clases y generar una automatizaciòn .github/workflows/publish_docs.yml (Github Workflow) utilizando DocFx (init, metadata y build) y publicar el site de documentaciòn generado en un Github Page. Generar una automatización de nombre .github/workflows/package_nuget.yml (Github Workflow) que ejecute: Pruebas unitarias y reporte de pruebas automatizadas Realice el analisis con SonarCloud. Contruya un archivo .nuget a partir del proyecto Bank.Domain y lo publique como un Paquete de Github Generar una automatización de nombre .github/workflows/release_version.yml (Github Workflow) que contruya la version (release) del paquete y publique en Github Releases e incluya pero ahi no esta el test unitaroi"
  },
  "docs/Bank.Domain.CreditCardFactory.html": {
    "href": "docs/Bank.Domain.CreditCardFactory.html",
    "title": "Class CreditCardFactory | Bank App",
    "summary": "Class CreditCardFactory Namespace Bank.Domain Assembly Bank.Domain.dll A simple static factory for creating ICreditCard instances by type name. public class CreditCardFactory Inheritance object CreditCardFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetCreditCard(string) Returns an ICreditCard implementation matching the provided cardType. public static ICreditCard GetCreditCard(string cardType) Parameters cardType string A string identifying the desired card type (e.g. \"MoneyBack\"). Returns ICreditCard An instance of ICreditCard or null if the type is unknown."
  },
  "docs/Bank.Domain.CreditCardFactoryMethod.html": {
    "href": "docs/Bank.Domain.CreditCardFactoryMethod.html",
    "title": "Class CreditCardFactoryMethod | Bank App",
    "summary": "Class CreditCardFactoryMethod Namespace Bank.Domain Assembly Bank.Domain.dll Base class for the Factory Method pattern. Subclasses override MakeProduct() to create concrete ICreditCard instances. public abstract class CreditCardFactoryMethod Inheritance object CreditCardFactoryMethod Derived MoneyBackFactoryMethod PlatinumFactoryMethod TitaniumFactoryMethod Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateProduct() Creates a product by delegating to MakeProduct() and returns it to the caller. public ICreditCard CreateProduct() Returns ICreditCard A new ICreditCard instance. MakeProduct() Factory method to be implemented by concrete factories. protected abstract ICreditCard MakeProduct() Returns ICreditCard A new ICreditCard instance."
  },
  "docs/Bank.Domain.ICreditCard.html": {
    "href": "docs/Bank.Domain.ICreditCard.html",
    "title": "Interface ICreditCard | Bank App",
    "summary": "Interface ICreditCard Namespace Bank.Domain Assembly Bank.Domain.dll Represents a credit card with common operations. Implementations provide the card type, credit limit and annual charge. public interface ICreditCard Methods GetAnnualCharge() Gets the annual charge for this card. int GetAnnualCharge() Returns int An integer representing the annual charge in the local currency. GetCardType() Gets the display name of the credit card type. string GetCardType() Returns string The card type name (for example, \"MoneyBack\"). GetCreditLimit() Gets the credit limit for this card. int GetCreditLimit() Returns int An integer representing the credit limit in the local currency."
  },
  "docs/Bank.Domain.MoneyBack.html": {
    "href": "docs/Bank.Domain.MoneyBack.html",
    "title": "Class MoneyBack | Bank App",
    "summary": "Class MoneyBack Namespace Bank.Domain Assembly Bank.Domain.dll A MoneyBack credit card implementation. Provides the card type, credit limit and annual charge for MoneyBack cards. public class MoneyBack : ICreditCard Inheritance object MoneyBack Implements ICreditCard Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetAnnualCharge() Gets the annual charge for this card. public int GetAnnualCharge() Returns int An integer representing the annual charge in the local currency. GetCardType() Gets the display name of the credit card type. public string GetCardType() Returns string The card type name (for example, \"MoneyBack\"). GetCreditLimit() Gets the credit limit for this card. public int GetCreditLimit() Returns int An integer representing the credit limit in the local currency."
  },
  "docs/Bank.Domain.MoneyBackFactoryMethod.html": {
    "href": "docs/Bank.Domain.MoneyBackFactoryMethod.html",
    "title": "Class MoneyBackFactoryMethod | Bank App",
    "summary": "Class MoneyBackFactoryMethod Namespace Bank.Domain Assembly Bank.Domain.dll Concrete factory method that creates MoneyBack cards. public class MoneyBackFactoryMethod : CreditCardFactoryMethod Inheritance object CreditCardFactoryMethod MoneyBackFactoryMethod Inherited Members CreditCardFactoryMethod.CreateProduct() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods MakeProduct() Creates a new MoneyBack instance. protected override ICreditCard MakeProduct() Returns ICreditCard A MoneyBack as ICreditCard."
  },
  "docs/Bank.Domain.Platinum.html": {
    "href": "docs/Bank.Domain.Platinum.html",
    "title": "Class Platinum | Bank App",
    "summary": "Class Platinum Namespace Bank.Domain Assembly Bank.Domain.dll A Platinum credit card implementation. Provides the card type, credit limit and annual charge for Platinum cards. public class Platinum : ICreditCard Inheritance object Platinum Implements ICreditCard Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetAnnualCharge() Gets the annual charge for this card. public int GetAnnualCharge() Returns int An integer representing the annual charge in the local currency. GetCardType() Gets the display name of the credit card type. public string GetCardType() Returns string The card type name (for example, \"MoneyBack\"). GetCreditLimit() Gets the credit limit for this card. public int GetCreditLimit() Returns int An integer representing the credit limit in the local currency."
  },
  "docs/Bank.Domain.PlatinumFactoryMethod.html": {
    "href": "docs/Bank.Domain.PlatinumFactoryMethod.html",
    "title": "Class PlatinumFactoryMethod | Bank App",
    "summary": "Class PlatinumFactoryMethod Namespace Bank.Domain Assembly Bank.Domain.dll Concrete factory method that creates Platinum cards. public class PlatinumFactoryMethod : CreditCardFactoryMethod Inheritance object CreditCardFactoryMethod PlatinumFactoryMethod Inherited Members CreditCardFactoryMethod.CreateProduct() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods MakeProduct() Creates a new Platinum instance. protected override ICreditCard MakeProduct() Returns ICreditCard A Platinum as ICreditCard."
  },
  "docs/Bank.Domain.Tests.CreditCardTests.html": {
    "href": "docs/Bank.Domain.Tests.CreditCardTests.html",
    "title": "Class CreditCardTests | Bank App",
    "summary": "Class CreditCardTests Namespace Bank.Domain.Tests Assembly Bank.Domain.Tests.dll public class CreditCardTests Inheritance object CreditCardTests Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GivenCreditTypePlatinumChoosen_WhenRequestCreditCard_ThenNewValidCreditCard() [Test] public void GivenCreditTypePlatinumChoosen_WhenRequestCreditCard_ThenNewValidCreditCard() GivenCreditTypeSelected_WhenRequestCreditCard_ThenNewValidCreditCard() [Test] public void GivenCreditTypeSelected_WhenRequestCreditCard_ThenNewValidCreditCard() GivenCreditTypeTitaniumChoosen_WhenRequestCreditCard_ThenNewValidCreditCard() [Test] public void GivenCreditTypeTitaniumChoosen_WhenRequestCreditCard_ThenNewValidCreditCard()"
  },
  "docs/Bank.Domain.Tests.html": {
    "href": "docs/Bank.Domain.Tests.html",
    "title": "Namespace Bank.Domain.Tests | Bank App",
    "summary": "Namespace Bank.Domain.Tests Classes CreditCardTests"
  },
  "docs/Bank.Domain.Titanium.html": {
    "href": "docs/Bank.Domain.Titanium.html",
    "title": "Class Titanium | Bank App",
    "summary": "Class Titanium Namespace Bank.Domain Assembly Bank.Domain.dll A Titanium credit card implementation. Provides the card type, credit limit and annual charge for Titanium cards. public class Titanium : ICreditCard Inheritance object Titanium Implements ICreditCard Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetAnnualCharge() Gets the annual charge for this card. public int GetAnnualCharge() Returns int An integer representing the annual charge in the local currency. GetCardType() Gets the display name of the credit card type. public string GetCardType() Returns string The card type name (for example, \"MoneyBack\"). GetCreditLimit() Gets the credit limit for this card. public int GetCreditLimit() Returns int An integer representing the credit limit in the local currency."
  },
  "docs/Bank.Domain.TitaniumFactoryMethod.html": {
    "href": "docs/Bank.Domain.TitaniumFactoryMethod.html",
    "title": "Class TitaniumFactoryMethod | Bank App",
    "summary": "Class TitaniumFactoryMethod Namespace Bank.Domain Assembly Bank.Domain.dll Concrete factory method that creates Titanium cards. public class TitaniumFactoryMethod : CreditCardFactoryMethod Inheritance object CreditCardFactoryMethod TitaniumFactoryMethod Inherited Members CreditCardFactoryMethod.CreateProduct() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods MakeProduct() Creates a new Titanium instance. protected override ICreditCard MakeProduct() Returns ICreditCard A Titanium as ICreditCard."
  },
  "docs/Bank.Domain.html": {
    "href": "docs/Bank.Domain.html",
    "title": "Namespace Bank.Domain | Bank App",
    "summary": "Namespace Bank.Domain Classes CreditCardFactory A simple static factory for creating ICreditCard instances by type name. CreditCardFactoryMethod Base class for the Factory Method pattern. Subclasses override MakeProduct() to create concrete ICreditCard instances. MoneyBack A MoneyBack credit card implementation. Provides the card type, credit limit and annual charge for MoneyBack cards. MoneyBackFactoryMethod Concrete factory method that creates MoneyBack cards. Platinum A Platinum credit card implementation. Provides the card type, credit limit and annual charge for Platinum cards. PlatinumFactoryMethod Concrete factory method that creates Platinum cards. Titanium A Titanium credit card implementation. Provides the card type, credit limit and annual charge for Titanium cards. TitaniumFactoryMethod Concrete factory method that creates Titanium cards. Interfaces ICreditCard Represents a credit card with common operations. Implementations provide the card type, credit limit and annual charge."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | Bank App",
    "summary": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | Bank App",
    "summary": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | Bank App",
    "summary": "This is the HOMEPAGE. Diagrama de Clases Pruebas Documentación generada por DocFx Docs (site) Contenido de docs/ generado"
  }
}